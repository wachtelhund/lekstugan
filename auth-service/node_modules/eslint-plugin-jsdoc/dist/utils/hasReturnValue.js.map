{"version":3,"file":"hasReturnValue.js","names":["isNewPromiseExpression","node","type","callee","name","isVoidPromise","typeParameters","params","undefinedKeywords","Set","hasReturnValue","promFilter","returnType","typeAnnotation","has","value","expression","body","some","bodyNode","consequent","alternate","block","handler","finalizer","cases","someCase","nde","argument","hasNonEmptyResolverCall","resolverName","arguments","length","undefined","test","elements","element","right","left","expressions","subExpression","properties","property","decorators","decorator","computed","key","declarations","id","init","quasi","object","source","hasValueOrExecutorHasNonEmptyResolveValue","anyPromiseAsReturn","prom"],"sources":["../../src/utils/hasReturnValue.js"],"sourcesContent":["/* eslint-disable jsdoc/no-undefined-types */\n/**\n * Checks if a node is a promise but has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n *\n * @param {object} node\n * @returns {boolean}\n */\nconst isNewPromiseExpression = (node) => {\n  return node && node.type === 'NewExpression' && node.callee.type === 'Identifier' &&\n    node.callee.name === 'Promise';\n};\n\nconst isVoidPromise = (node) => {\n  return node?.typeParameters?.params?.[0]?.type === 'TSVoidKeyword';\n};\n\nconst undefinedKeywords = new Set([\n  'TSVoidKeyword', 'TSUndefinedKeyword', 'TSNeverKeyword',\n]);\n\n/**\n * @callback PromiseFilter\n * @param {object} node\n * @returns {boolean}\n */\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n *\n * @param {object} node\n * @param {PromiseFilter} promFilter\n * @returns {boolean|Node}\n */\n// eslint-disable-next-line complexity\nconst hasReturnValue = (node, promFilter) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n  case 'TSDeclareFunction':\n  case 'TSFunctionType':\n  case 'TSMethodSignature': {\n    const type = node?.returnType?.typeAnnotation?.type;\n    return type && !undefinedKeywords.has(type);\n  }\n\n  case 'MethodDefinition':\n    return hasReturnValue(node.value, promFilter);\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return node.expression && (!isNewPromiseExpression(node.body) || !isVoidPromise(node.body)) ||\n      hasReturnValue(node.body, promFilter);\n  }\n\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return bodyNode.type !== 'FunctionDeclaration' && hasReturnValue(bodyNode, promFilter);\n    });\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasReturnValue(node.body, promFilter);\n  }\n\n  case 'IfStatement': {\n    return hasReturnValue(node.consequent, promFilter) || hasReturnValue(node.alternate, promFilter);\n  }\n\n  case 'TryStatement': {\n    return hasReturnValue(node.block, promFilter) ||\n      hasReturnValue(node.handler && node.handler.body, promFilter) ||\n      hasReturnValue(node.finalizer, promFilter);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasReturnValue(nde, promFilter);\n        });\n      },\n    );\n  }\n\n  case 'ReturnStatement': {\n    // void return does not count.\n    if (node.argument === null) {\n      return false;\n    }\n\n    if (promFilter && isNewPromiseExpression(node.argument)) {\n      // Let caller decide how to filter, but this is, at the least,\n      //   a return of sorts and truthy\n      return promFilter(node.argument);\n    }\n\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * Avoids further checking child nodes if a nested function shadows the\n * resolver, but otherwise, if name is used (by call or passed in as an\n * argument to another function), will be considered as non-empty.\n *\n * This could check for redeclaration of the resolver, but as such is\n * unlikely, we avoid the performance cost of checking everywhere for\n * (re)declarations or assignments.\n *\n * @param {AST} node\n * @param {string} resolverName\n * @returns {boolean}\n */\n// eslint-disable-next-line complexity\nconst hasNonEmptyResolverCall = (node, resolverName) => {\n  if (!node) {\n    return false;\n  }\n\n  // Arrow function without block\n  switch (node.type) {\n  // istanbul ignore next -- In Babel?\n  case 'OptionalCallExpression':\n  case 'CallExpression':\n    return node.callee.name === resolverName && (\n\n      // Implicit or explicit undefined\n      node.arguments.length > 1 || node.arguments[0] !== undefined\n    ) ||\n      node.arguments.some((nde) => {\n        // Being passed in to another function (which might invoke it)\n        return nde.type === 'Identifier' && nde.name === resolverName ||\n\n          // Handle nested items\n          hasNonEmptyResolverCall(nde, resolverName);\n      });\n  case 'ChainExpression':\n  case 'Decorator':\n  case 'ExpressionStatement':\n    return hasNonEmptyResolverCall(node.expression, resolverName);\n  case 'ClassBody':\n  case 'BlockStatement':\n    return node.body.some((bodyNode) => {\n      return hasNonEmptyResolverCall(bodyNode, resolverName);\n    });\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    // Shadowing\n    if (node.params[0]?.name === resolverName) {\n      return false;\n    }\n\n    return hasNonEmptyResolverCall(node.body, resolverName);\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasNonEmptyResolverCall(node.body, resolverName);\n  }\n\n  case 'ConditionalExpression':\n  case 'IfStatement': {\n    return hasNonEmptyResolverCall(node.test, resolverName) ||\n      hasNonEmptyResolverCall(node.consequent, resolverName) ||\n      hasNonEmptyResolverCall(node.alternate, resolverName);\n  }\n\n  case 'TryStatement': {\n    return hasNonEmptyResolverCall(node.block, resolverName) ||\n      hasNonEmptyResolverCall(node.handler && node.handler.body, resolverName) ||\n      hasNonEmptyResolverCall(node.finalizer, resolverName);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasNonEmptyResolverCall(nde, resolverName);\n        });\n      },\n    );\n  }\n\n  case 'ArrayPattern':\n  case 'ArrayExpression':\n    return node.elements.some((element) => {\n      return hasNonEmptyResolverCall(element, resolverName);\n    });\n\n  case 'AssignmentPattern':\n    return hasNonEmptyResolverCall(node.right, resolverName);\n\n  case 'AssignmentExpression':\n  case 'BinaryExpression':\n  case 'LogicalExpression': {\n    return hasNonEmptyResolverCall(node.left, resolverName) ||\n      hasNonEmptyResolverCall(node.right, resolverName);\n  }\n\n  // Comma\n  case 'SequenceExpression':\n  case 'TemplateLiteral':\n    return node.expressions.some((subExpression) => {\n      return hasNonEmptyResolverCall(subExpression, resolverName);\n    });\n\n  case 'ObjectPattern':\n  case 'ObjectExpression':\n    return node.properties.some((property) => {\n      return hasNonEmptyResolverCall(property, resolverName);\n    });\n  // istanbul ignore next -- In Babel?\n  case 'ClassMethod':\n  case 'MethodDefinition':\n    return node.decorators && node.decorators.some((decorator) => {\n      return hasNonEmptyResolverCall(decorator, resolverName);\n    }) ||\n      node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n\n  // istanbul ignore next -- In Babel?\n  case 'ObjectProperty':\n  /* eslint-disable no-fallthrough */\n  // istanbul ignore next -- In Babel?\n  case 'PropertyDefinition':\n  // istanbul ignore next -- In Babel?\n  case 'ClassProperty':\n  /* eslint-enable no-fallthrough */\n  case 'Property':\n    return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      hasNonEmptyResolverCall(node.value, resolverName);\n  // istanbul ignore next -- In Babel?\n  case 'ObjectMethod':\n    // istanbul ignore next -- In Babel?\n    return node.computed && hasNonEmptyResolverCall(node.key, resolverName) ||\n      node.arguments.some((nde) => {\n        return hasNonEmptyResolverCall(nde, resolverName);\n      });\n\n  case 'ClassExpression':\n  case 'ClassDeclaration':\n    return hasNonEmptyResolverCall(node.body, resolverName);\n\n  case 'AwaitExpression':\n  case 'SpreadElement':\n  case 'UnaryExpression':\n  case 'YieldExpression':\n    return hasNonEmptyResolverCall(node.argument, resolverName);\n\n  case 'VariableDeclaration': {\n    return node.declarations.some((nde) => {\n      return hasNonEmptyResolverCall(nde, resolverName);\n    });\n  }\n\n  case 'VariableDeclarator': {\n    return hasNonEmptyResolverCall(node.id, resolverName) ||\n      hasNonEmptyResolverCall(node.init, resolverName);\n  }\n\n  case 'TaggedTemplateExpression':\n    return hasNonEmptyResolverCall(node.quasi, resolverName);\n\n  // ?.\n  // istanbul ignore next -- In Babel?\n  case 'OptionalMemberExpression':\n  case 'MemberExpression':\n    return hasNonEmptyResolverCall(node.object, resolverName) ||\n      hasNonEmptyResolverCall(node.property, resolverName);\n\n  // istanbul ignore next -- In Babel?\n  case 'Import':\n  case 'ImportExpression':\n    return hasNonEmptyResolverCall(node.source, resolverName);\n\n  case 'ReturnStatement': {\n    if (node.argument === null) {\n      return false;\n    }\n\n    return hasNonEmptyResolverCall(node.argument, resolverName);\n  }\n\n  /*\n  // Shouldn't need to parse literals/literal components, etc.\n\n  case 'Identifier':\n  case 'TemplateElement':\n  case 'Super':\n  // Exports not relevant in this context\n  */\n  default:\n    return false;\n  }\n};\n\n/**\n * Checks if a Promise executor has no resolve value or an empty value.\n * An `undefined` resolve does not count.\n *\n * @param {object} node\n * @param {boolean} anyPromiseAsReturn\n * @returns {boolean}\n */\nconst hasValueOrExecutorHasNonEmptyResolveValue = (node, anyPromiseAsReturn) => {\n  return hasReturnValue(node, (prom) => {\n    if (anyPromiseAsReturn) {\n      return true;\n    }\n\n    if (isVoidPromise(prom)) {\n      return false;\n    }\n\n    const [\n      {\n        params,\n        body,\n      } = {},\n    ] = prom.arguments;\n\n    if (!params?.length) {\n      return false;\n    }\n\n    const [\n      {\n        name: resolverName,\n      },\n    ] = params;\n\n    return hasNonEmptyResolverCall(body, resolverName);\n  });\n};\n\nexport {\n  hasReturnValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n};\n"],"mappings":"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"}